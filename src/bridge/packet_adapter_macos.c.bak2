// SoftEther VPN Zig Client - macOS Packet Adapter Implementation
// Uses macOS utun kernel interface for packet forwarding

#include "packet_adapter_macos.h"
#include "../../SoftEtherVPN_Stable/src/Mayaqua/Mayaqua.h"
#include "../../SoftEtherVPN_Stable/src/Cedar/Cedar.h"
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/kern_control.h>
#include <sys/sys_domain.h>
#include <net/if.h>
#include <net/if_utun.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>

#define TUN_MTU 1500
#define MAX_PACKET_SIZE 2048
#define RECV_QUEUE_MAX 1024

// DHCP configuration state
typedef enum {
    DHCP_STATE_INIT = 0,
    DHCP_STATE_DISCOVER_SENT = 1,
    DHCP_STATE_OFFER_RECEIVED = 2,
    DHCP_STATE_REQUEST_SENT = 3,
    DHCP_STATE_CONFIGURED = 4
} DHCP_STATE;

static DHCP_STATE g_dhcp_state = DHCP_STATE_INIT;
static UCHAR g_my_mac[6] = {0};
static UINT32 g_dhcp_xid = 0;
static UINT32 g_dhcp_server_ip = 0;
static UINT64 g_connection_start_time = 0;  // Timestamp when connection established
static UINT32 g_offered_ip = 0;
static UINT32 g_offered_mask = 0;
static UINT32 g_offered_gw = 0;

// Configure the TUN interface with IP address
static bool ConfigureTunInterface(const char *device, UINT32 ip, UINT32 netmask, UINT32 gateway) {
    char cmd[512];
    char ip_str[32], mask_str[32], gw_str[32];
    
    // Convert IPs to strings (network byte order)
    snprintf(ip_str, sizeof(ip_str), "%d.%d.%d.%d",
             (ip >> 24) & 0xFF, (ip >> 16) & 0xFF, (ip >> 8) & 0xFF, ip & 0xFF);
    snprintf(mask_str, sizeof(mask_str), "%d.%d.%d.%d",
             (netmask >> 24) & 0xFF, (netmask >> 16) & 0xFF, (netmask >> 8) & 0xFF, netmask & 0xFF);
    snprintf(gw_str, sizeof(gw_str), "%d.%d.%d.%d",
             (gateway >> 24) & 0xFF, (gateway >> 16) & 0xFF, (gateway >> 8) & 0xFF, gateway & 0xFF);
    
    printf("\n");
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘     DHCP Configuration Received!           â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘ Device:    %-32sâ•‘\n", device);
    printf("â•‘ IP:        %-32sâ•‘\n", ip_str);
    printf("â•‘ Netmask:   %-32sâ•‘\n", mask_str);
    printf("â•‘ Gateway:   %-32sâ•‘\n", gw_str);
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("\n");
    
    // Set IP address and netmask
    snprintf(cmd, sizeof(cmd), "ifconfig %s %s %s up", device, ip_str, mask_str);
    printf("[ConfigureTunInterface] Executing: %s\n", cmd);
    if (system(cmd) != 0) {
        printf("[ConfigureTunInterface] âŒ Failed to configure interface\n");
        return false;
    }
    
    // Add default route via gateway
    if (gateway != 0) {
        // Delete existing default route (may fail, that's OK)
        system("route delete default >/dev/null 2>&1");
        
        snprintf(cmd, sizeof(cmd), "route add default %s", gw_str);
        printf("[ConfigureTunInterface] Executing: %s\n", cmd);
        if (system(cmd) != 0) {
            printf("[ConfigureTunInterface] âš ï¸  Failed to add default route (may already exist)\n");
        }
    }
    
    printf("[ConfigureTunInterface] âœ… Interface configured successfully\n\n");
    return true;
}

// Build DHCP DISCOVER packet
static UCHAR* BuildDhcpDiscover(UCHAR *my_mac, UINT32 xid, UINT *out_size) {
    static UCHAR packet[1024];
    UINT pos = 0;
    
    // Ethernet header (14 bytes)
    // Destination MAC: broadcast
    packet[pos++] = 0xFF; packet[pos++] = 0xFF; packet[pos++] = 0xFF;
    packet[pos++] = 0xFF; packet[pos++] = 0xFF; packet[pos++] = 0xFF;
    // Source MAC
    memcpy(packet + pos, my_mac, 6); pos += 6;
    // EtherType: IPv4
    packet[pos++] = 0x08; packet[pos++] = 0x00;
    
    // IPv4 header (20 bytes)
    packet[pos++] = 0x45; // Version 4, IHL 5
    packet[pos++] = 0x00; // DSCP/ECN
    USHORT total_len = 20 + 8 + 240 + 64; // IP + UDP + DHCP
    packet[pos++] = (total_len >> 8) & 0xFF;
    packet[pos++] = total_len & 0xFF;
    packet[pos++] = 0x00; packet[pos++] = 0x00; // ID
    packet[pos++] = 0x00; packet[pos++] = 0x00; // Flags/Fragment
    packet[pos++] = 64; // TTL
    packet[pos++] = 17; // Protocol: UDP
    packet[pos++] = 0x00; packet[pos++] = 0x00; // Checksum (will calculate)
    // Source IP: 0.0.0.0
    packet[pos++] = 0; packet[pos++] = 0; packet[pos++] = 0; packet[pos++] = 0;
    // Dest IP: 255.255.255.255
    packet[pos++] = 255; packet[pos++] = 255; packet[pos++] = 255; packet[pos++] = 255;
    
    // Calculate IP checksum
    UINT ip_header_start = 14;
    UINT checksum = 0;
    for (int i = 0; i < 20; i += 2) {
        checksum += (packet[ip_header_start + i] << 8) | packet[ip_header_start + i + 1];
    }
    checksum = (checksum >> 16) + (checksum & 0xFFFF);
    checksum = ~checksum & 0xFFFF;
    packet[ip_header_start + 10] = (checksum >> 8) & 0xFF;
    packet[ip_header_start + 11] = checksum & 0xFF;
    
    // UDP header (8 bytes)
    packet[pos++] = 0x00; packet[pos++] = 68; // Source port: 68 (DHCP client)
    packet[pos++] = 0x00; packet[pos++] = 67; // Dest port: 67 (DHCP server)
    USHORT udp_len = 8 + 240 + 64;
    packet[pos++] = (udp_len >> 8) & 0xFF;
    packet[pos++] = udp_len & 0xFF;
    packet[pos++] = 0x00; packet[pos++] = 0x00; // Checksum (optional for IPv4)
    
    // DHCP header (240 bytes minimum)
    packet[pos++] = 0x01; // op: BOOTREQUEST
    packet[pos++] = 0x01; // htype: Ethernet
    packet[pos++] = 0x06; // hlen: 6
    packet[pos++] = 0x00; // hops: 0
    // Transaction ID (4 bytes)
    packet[pos++] = (xid >> 24) & 0xFF;
    packet[pos++] = (xid >> 16) & 0xFF;
    packet[pos++] = (xid >> 8) & 0xFF;
    packet[pos++] = xid & 0xFF;
    // secs, flags
    packet[pos++] = 0x00; packet[pos++] = 0x00;
    packet[pos++] = 0x80; packet[pos++] = 0x00; // Broadcast flag
    // ciaddr, yiaddr, siaddr, giaddr (all zeros)
    for (int i = 0; i < 16; i++) packet[pos++] = 0x00;
    // chaddr (client MAC)
    memcpy(packet + pos, my_mac, 6); pos += 6;
    for (int i = 0; i < 10; i++) packet[pos++] = 0x00; // Padding
    // sname, file (zeros)
    for (int i = 0; i < 192; i++) packet[pos++] = 0x00;
    
    // DHCP magic cookie
    packet[pos++] = 0x63; packet[pos++] = 0x82;
    packet[pos++] = 0x53; packet[pos++] = 0x63;
    
    // DHCP options
    // Option 53: DHCP Message Type = DISCOVER (1)
    packet[pos++] = 53; packet[pos++] = 1; packet[pos++] = 1;
    
    // Option 55: Parameter Request List
    packet[pos++] = 55; packet[pos++] = 4;
    packet[pos++] = 1;  // Subnet Mask
    packet[pos++] = 3;  // Router
    packet[pos++] = 6;  // DNS
    packet[pos++] = 15; // Domain Name
    
    // Option 255: End
    packet[pos++] = 255;
    
    *out_size = pos;
    return packet;
}

// Check if packet is a DHCP ACK and extract configuration
static bool ParseDhcpAck(UCHAR *data, UINT size, UINT32 expected_xid, UINT32 *out_ip, UINT32 *out_mask, UINT32 *out_gw) {
    // Skip Ethernet header (14 bytes)
    if (size < 14) return false;
    USHORT ethertype = (data[12] << 8) | data[13];
    if (ethertype != 0x0800) return false;
    
    data += 14;
    size -= 14;
    
    // Check IPv4 UDP
    if (size < 20) return false;
    UCHAR protocol = data[9];
    if (protocol != 17) return false;
    
    // Get IP header length
    UCHAR ihl = (data[0] & 0x0F) * 4;
    if (size < ihl + 8) return false;
    
    // Check UDP ports
    data += ihl;
    size -= ihl;
    USHORT src_port = (data[0] << 8) | data[1];
    USHORT dst_port = (data[2] << 8) | data[3];
    if (src_port != 67 || dst_port != 68) return false;
    
    // Skip UDP header
    data += 8;
    size -= 8;
    
    // Parse DHCP
    if (size < 240) return false;
    if (data[0] != 2) return false; // BOOTREPLY
    
    // Check transaction ID
    UINT32 xid = (data[4] << 24) | (data[5] << 16) | (data[6] << 8) | data[7];
    if (xid != expected_xid) return false;
    
    // Extract yiaddr (your IP address)
    UINT32 yiaddr = (data[16] << 24) | (data[17] << 16) | (data[18] << 8) | data[19];
    if (yiaddr == 0) return false;
    
    *out_ip = yiaddr;
    
    // Parse DHCP options
    if (size < 240) return false;
    UINT32 magic = (data[236] << 24) | (data[237] << 16) | (data[238] << 8) | data[239];
    if (magic != 0x63825363) return false;
    
    UCHAR *options = data + 240;
    UINT options_len = size - 240;
    UINT pos = 0;
    
    *out_mask = 0;
    *out_gw = 0;
    bool is_ack = false;
    
    while (pos < options_len) {
        UCHAR opt_type = options[pos++];
        if (opt_type == 0xFF) break;
        if (opt_type == 0x00) continue;
        
        if (pos >= options_len) break;
        UCHAR opt_len = options[pos++];
        if (pos + opt_len > options_len) break;
        
        switch (opt_type) {
            case 53: // DHCP Message Type
                if (opt_len >= 1 && options[pos] == 5) {
                    is_ack = true; // DHCP ACK
                }
                break;
            case 1: // Subnet Mask
                if (opt_len >= 4) {
                    *out_mask = (options[pos] << 24) | (options[pos+1] << 16) |
                               (options[pos+2] << 8) | options[pos+3];
                }
                break;
            case 3: // Router/Gateway
                if (opt_len >= 4) {
                    *out_gw = (options[pos] << 24) | (options[pos+1] << 16) |
                             (options[pos+2] << 8) | options[pos+3];
                }
                break;
        }
        
        pos += opt_len;
    }
    
    return is_ack && (*out_ip != 0);
}

// Parse DHCP OFFER packet
static bool ParseDhcpOffer(UCHAR *data, UINT size, UINT32 expected_xid, UINT32 *out_ip, UINT32 *out_mask, UINT32 *out_gw, UINT32 *out_server) {
    // Skip Ethernet header (14 bytes)
    if (size < 14) return false;
    USHORT ethertype = (data[12] << 8) | data[13];
    if (ethertype != 0x0800) return false;
    
    data += 14;
    size -= 14;
    
    // Check IPv4 UDP
    if (size < 20) return false;
    UCHAR protocol = data[9];
    if (protocol != 17) return false;
    
    // Get IP header length
    UCHAR ihl = (data[0] & 0x0F) * 4;
    if (size < ihl + 8) return false;
    
    // Check UDP ports (server:67 -> client:68)
    data += ihl;
    size -= ihl;
    USHORT src_port = (data[0] << 8) | data[1];
    USHORT dst_port = (data[2] << 8) | data[3];
    if (src_port != 67 || dst_port != 68) return false;
    
    // Skip UDP header
    data += 8;
    size -= 8;
    
    // Parse DHCP
    if (size < 240) return false;
    if (data[0] != 2) return false; // BOOTREPLY
    
    // Check transaction ID
    UINT32 xid = (data[4] << 24) | (data[5] << 16) | (data[6] << 8) | data[7];
    if (xid != expected_xid) return false;
    
    // Extract yiaddr (offered IP address)
    UINT32 yiaddr = (data[16] << 24) | (data[17] << 16) | (data[18] << 8) | data[19];
    if (yiaddr == 0) return false;
    *out_ip = yiaddr;
    
    // Extract siaddr (server IP)
    UINT32 siaddr = (data[20] << 24) | (data[21] << 16) | (data[22] << 8) | data[23];
    
    // Parse DHCP options
    if (size < 240) return false;
    UINT32 magic = (data[236] << 24) | (data[237] << 16) | (data[238] << 8) | data[239];
    if (magic != 0x63825363) return false;
    
    UCHAR *options = data + 240;
    UINT options_len = size - 240;
    UINT pos = 0;
    
    *out_mask = 0;
    *out_gw = 0;
    *out_server = 0;
    bool is_offer = false;
    
    while (pos < options_len) {
        UCHAR opt_type = options[pos++];
        if (opt_type == 0xFF) break;
        if (opt_type == 0x00) continue;
        
        if (pos >= options_len) break;
        UCHAR opt_len = options[pos++];
        if (pos + opt_len > options_len) break;
        
        switch (opt_type) {
            case 53: // DHCP Message Type
                if (opt_len >= 1 && options[pos] == 2) {
                    is_offer = true; // DHCP OFFER
                }
                break;
            case 1: // Subnet Mask
                if (opt_len >= 4) {
                    *out_mask = (options[pos] << 24) | (options[pos+1] << 16) |
                               (options[pos+2] << 8) | options[pos+3];
                }
                break;
            case 3: // Router/Gateway
                if (opt_len >= 4) {
                    *out_gw = (options[pos] << 24) | (options[pos+1] << 16) |
                             (options[pos+2] << 8) | options[pos+3];
                }
                break;
            case 54: // DHCP Server Identifier
                if (opt_len >= 4) {
                    *out_server = (options[pos] << 24) | (options[pos+1] << 16) |
                                 (options[pos+2] << 8) | options[pos+3];
                }
                break;
        }
        
        pos += opt_len;
    }
    
    // Use siaddr if server option not found
    if (*out_server == 0 && siaddr != 0) {
        *out_server = siaddr;
    }
    
    return is_offer && (*out_ip != 0);
}

// Build DHCP REQUEST packet
static UCHAR* BuildDhcpRequest(UCHAR *my_mac, UINT32 xid, UINT32 requested_ip, UINT32 server_ip, UINT *out_size) {
    static UCHAR packet[1024];
    UINT pos = 0;
    
    // Ethernet header (14 bytes)
    // Destination MAC: broadcast
    packet[pos++] = 0xFF; packet[pos++] = 0xFF; packet[pos++] = 0xFF;
    packet[pos++] = 0xFF; packet[pos++] = 0xFF; packet[pos++] = 0xFF;
    // Source MAC
    memcpy(packet + pos, my_mac, 6); pos += 6;
    // EtherType: IPv4
    packet[pos++] = 0x08; packet[pos++] = 0x00;
    
    // IPv4 header (20 bytes)
    packet[pos++] = 0x45; // Version 4, IHL 5
    packet[pos++] = 0x00; // DSCP/ECN
    USHORT total_len = 20 + 8 + 240 + 80; // IP + UDP + DHCP + extra options
    packet[pos++] = (total_len >> 8) & 0xFF;
    packet[pos++] = total_len & 0xFF;
    packet[pos++] = 0x00; packet[pos++] = 0x00; // ID
    packet[pos++] = 0x00; packet[pos++] = 0x00; // Flags/Fragment
    packet[pos++] = 64; // TTL
    packet[pos++] = 17; // Protocol: UDP
    packet[pos++] = 0x00; packet[pos++] = 0x00; // Checksum (will calculate)
    // Source IP: 0.0.0.0
    packet[pos++] = 0; packet[pos++] = 0; packet[pos++] = 0; packet[pos++] = 0;
    // Dest IP: 255.255.255.255
    packet[pos++] = 255; packet[pos++] = 255; packet[pos++] = 255; packet[pos++] = 255;
    
    // Calculate IP checksum
    UINT ip_header_start = 14;
    UINT checksum = 0;
    for (int i = 0; i < 20; i += 2) {
        checksum += (packet[ip_header_start + i] << 8) | packet[ip_header_start + i + 1];
    }
    checksum = (checksum >> 16) + (checksum & 0xFFFF);
    checksum = ~checksum & 0xFFFF;
    packet[ip_header_start + 10] = (checksum >> 8) & 0xFF;
    packet[ip_header_start + 11] = checksum & 0xFF;
    
    // UDP header (8 bytes)
    packet[pos++] = 0x00; packet[pos++] = 68; // Source port: 68 (DHCP client)
    packet[pos++] = 0x00; packet[pos++] = 67; // Dest port: 67 (DHCP server)
    USHORT udp_len = 8 + 240 + 80;
    packet[pos++] = (udp_len >> 8) & 0xFF;
    packet[pos++] = udp_len & 0xFF;
    packet[pos++] = 0x00; packet[pos++] = 0x00; // Checksum (optional for IPv4)
    
    // DHCP header (240 bytes minimum)
    packet[pos++] = 0x01; // op: BOOTREQUEST
    packet[pos++] = 0x01; // htype: Ethernet
    packet[pos++] = 0x06; // hlen: 6
    packet[pos++] = 0x00; // hops: 0
    // Transaction ID (4 bytes)
    packet[pos++] = (xid >> 24) & 0xFF;
    packet[pos++] = (xid >> 16) & 0xFF;
    packet[pos++] = (xid >> 8) & 0xFF;
    packet[pos++] = xid & 0xFF;
    // secs, flags
    packet[pos++] = 0x00; packet[pos++] = 0x00;
    packet[pos++] = 0x80; packet[pos++] = 0x00; // Broadcast flag
    // ciaddr, yiaddr, siaddr, giaddr (all zeros)
    for (int i = 0; i < 16; i++) packet[pos++] = 0x00;
    // chaddr (client MAC)
    memcpy(packet + pos, my_mac, 6); pos += 6;
    for (int i = 0; i < 10; i++) packet[pos++] = 0x00; // Padding
    // sname, file (zeros)
    for (int i = 0; i < 192; i++) packet[pos++] = 0x00;
    
    // DHCP magic cookie
    packet[pos++] = 0x63; packet[pos++] = 0x82;
    packet[pos++] = 0x53; packet[pos++] = 0x63;
    
    // DHCP options
    // Option 53: DHCP Message Type = REQUEST (3)
    packet[pos++] = 53; packet[pos++] = 1; packet[pos++] = 3;
    
    // Option 50: Requested IP Address
    packet[pos++] = 50; packet[pos++] = 4;
    packet[pos++] = (requested_ip >> 24) & 0xFF;
    packet[pos++] = (requested_ip >> 16) & 0xFF;
    packet[pos++] = (requested_ip >> 8) & 0xFF;
    packet[pos++] = requested_ip & 0xFF;
    
    // Option 54: DHCP Server Identifier
    packet[pos++] = 54; packet[pos++] = 4;
    packet[pos++] = (server_ip >> 24) & 0xFF;
    packet[pos++] = (server_ip >> 16) & 0xFF;
    packet[pos++] = (server_ip >> 8) & 0xFF;
    packet[pos++] = server_ip & 0xFF;
    
    // Option 55: Parameter Request List
    packet[pos++] = 55; packet[pos++] = 4;
    packet[pos++] = 1;  // Subnet Mask
    packet[pos++] = 3;  // Router
    packet[pos++] = 6;  // DNS
    packet[pos++] = 15; // Domain Name
    
    // Option 255: End
    packet[pos++] = 255;
    
    *out_size = pos;
    return packet;
}

// Background thread for reading packets from TUN device
void MacOsTunReadThread(THREAD *t, void *param) {
    MACOS_TUN_CONTEXT *ctx = (MACOS_TUN_CONTEXT *)param;
    UCHAR buf[MAX_PACKET_SIZE];
    
    printf("[MacOsTunReadThread] === THREAD STARTED === fd=%d\n", ctx->tun_fd);
    fflush(stdout);
    
    // Signal thread is initialized
    printf("[MacOsTunReadThread] About to call NoticeThreadInit()...\n");
    fflush(stdout);
    
    NoticeThreadInit(t);
    
    printf("[MacOsTunReadThread] NoticeThreadInit() called, entering read loop\n");
    fflush(stdout);
    
    while (!ctx->halt) {
        // Read packet from TUN device (blocking)
        int n = read(ctx->tun_fd, buf, sizeof(buf));
        
        if (n < 0) {
            if (errno == EINTR || errno == EAGAIN) {
                continue;
            }
            printf("[MacOsTunReadThread] Read error: %s\n", strerror(errno));
            break;
        }
        
        if (n == 0) {
            printf("[MacOsTunReadThread] TUN device closed\n");
            break;
        }
        
        // Skip 4-byte protocol header (AF_INET/AF_INET6)
        if (n < 4) {
            continue;
        }
        
        // Allocate packet and copy data
        void *packet_data = Malloc(n - 4);
        Copy(packet_data, buf + 4, n - 4);
        
        TUN_PACKET *pkt = ZeroMalloc(sizeof(TUN_PACKET));
        pkt->data = packet_data;
        pkt->size = n - 4;
        
        // Add to receive queue
        Lock(ctx->queue_lock);
        {
            if (ctx->recv_queue->num_item < RECV_QUEUE_MAX) {
                InsertQueue(ctx->recv_queue, pkt);
                ctx->bytes_received += pkt->size;
                ctx->packets_received++;
            } else {
                // Queue full, drop packet
                Free(pkt->data);
                Free(pkt);
                printf("[MacOsTunReadThread] Queue full, dropping packet\n");
            }
        }
        Unlock(ctx->queue_lock);
        
        // Cancel any blocking waits
        if (ctx->cancel) {
            Cancel(ctx->cancel);
        }
    }
    
    printf("[MacOsTunReadThread] Exiting\n");
}

// Open a macOS TUN device using utun kernel control interface
int OpenMacOsTunDevice(char *device_name, size_t device_name_size) {
    struct sockaddr_ctl addr;
    struct ctl_info info;
    int fd = -1;
    int unit_number;
    
    // Get utun control ID first (only need to do this once)
    int temp_fd = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL);
    if (temp_fd < 0) {
        printf("[OpenMacOsTunDevice] Failed to create socket: %s\n", strerror(errno));
        return -1;
    }
    
    Zero(&info, sizeof(info));
    StrCpy(info.ctl_name, sizeof(info.ctl_name), UTUN_CONTROL_NAME);
    
    if (ioctl(temp_fd, CTLIOCGINFO, &info) < 0) {
        printf("[OpenMacOsTunDevice] ioctl CTLIOCGINFO failed: %s\n", strerror(errno));
        close(temp_fd);
        return -1;
    }
    close(temp_fd);
    
    // Try to connect to utun devices (0-15)
    // Start from 0 and find the first available one
    for (unit_number = 0; unit_number < 16; unit_number++) {
        // Create socket for kernel control
        fd = socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL);
        if (fd < 0) {
            printf("[OpenMacOsTunDevice] Failed to create socket for utun%d: %s\n", 
                   unit_number, strerror(errno));
            continue;
        }
        
        // Connect to utun kernel control
        Zero(&addr, sizeof(addr));
        addr.sc_len = sizeof(addr);
        addr.sc_family = AF_SYSTEM;
        addr.ss_sysaddr = AF_SYS_CONTROL;
        addr.sc_id = info.ctl_id;
        addr.sc_unit = unit_number + 1; // utun0 = 1, utun1 = 2, etc.
        
        if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
            printf("[OpenMacOsTunDevice] utun%d busy (%s), trying next...\n", 
                   unit_number, strerror(errno));
            close(fd);
            fd = -1;
            continue;
        }
        
        // Successfully connected!
        printf("[OpenMacOsTunDevice] Successfully connected to utun%d\n", unit_number);
        break;
    }
    
    if (fd < 0) {
        printf("[OpenMacOsTunDevice] Failed to find available utun device\n");
        return -1;
    }
    
    // Get the device name
    socklen_t optlen = (socklen_t)device_name_size;
    if (getsockopt(fd, SYSPROTO_CONTROL, UTUN_OPT_IFNAME, device_name, &optlen) < 0) {
        printf("[OpenMacOsTunDevice] getsockopt UTUN_OPT_IFNAME failed: %s\n", strerror(errno));
        StrCpy(device_name, device_name_size, "utun?");
    }
    
    // Set non-blocking mode
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags >= 0) {
        fcntl(fd, F_SETFL, flags | O_NONBLOCK);
    }
    
    printf("[OpenMacOsTunDevice] Created TUN device: %s (fd=%d)\n", device_name, fd);
    return fd;
}

// Close TUN device
void CloseMacOsTunDevice(int fd) {
    if (fd >= 0) {
        printf("[CloseMacOsTunDevice] Closing fd=%d\n", fd);
        close(fd);
    }
}

// PA_INIT callback - Initialize TUN device
bool MacOsTunInit(SESSION *s) {
    MACOS_TUN_CONTEXT *ctx;
    
    printf("[MacOsTunInit] === ENTER === session=%p\n", s);
    fflush(stdout);
    
    if (s == NULL) {
        printf("[MacOsTunInit] ERROR: session is NULL\n");
        fflush(stdout);
        return false;
    }
    
    if (s->PacketAdapter == NULL) {
        printf("[MacOsTunInit] ERROR: PacketAdapter is NULL\n");
        fflush(stdout);
        return false;
    }
    
    if (s->PacketAdapter->Param != NULL) {
        printf("[MacOsTunInit] ERROR: Param already set\n");
        fflush(stdout);
        return false;
    }
    
    printf("[MacOsTunInit] Validation passed, allocating context\n");
    fflush(stdout);
    
    // Allocate context
    printf("[MacOsTunInit] Allocating context structure\n");
    fflush(stdout);
    ctx = ZeroMalloc(sizeof(MACOS_TUN_CONTEXT));
    ctx->session = s;
    ctx->halt = false;
    printf("[MacOsTunInit] Context allocated at %p\n", ctx);
    fflush(stdout);
    
    // Open TUN device
    printf("[MacOsTunInit] Opening TUN device...\n");
    fflush(stdout);
    ctx->tun_fd = OpenMacOsTunDevice(ctx->device_name, sizeof(ctx->device_name));
    if (ctx->tun_fd < 0) {
        printf("[MacOsTunInit] ERROR: Failed to open TUN device\n");
        fflush(stdout);
        Free(ctx);
        return false;
    }
    printf("[MacOsTunInit] TUN device opened: %s (fd=%d)\n", ctx->device_name, ctx->tun_fd);
    fflush(stdout);
    
    // Initialize DHCP state
    printf("[MacOsTunInit] Initializing DHCP state...\n");
    fflush(stdout);
    g_dhcp_state = DHCP_STATE_INIT;
    g_connection_start_time = Tick64();  // Record when connection was established
    
    // Generate MAC address like the official SoftEther client does
    // Format: CA:XX:XX:XX:XX:XX (CA prefix is standard for IPC)
    g_my_mac[0] = 0xCA;
    for (int i = 1; i < 6; i++) {
        g_my_mac[i] = (UCHAR)(rand() % 256);
    }
    printf("[MacOsTunInit] Generated MAC: %02x:%02x:%02x:%02x:%02x:%02x\n",
           g_my_mac[0], g_my_mac[1], g_my_mac[2], 
           g_my_mac[3], g_my_mac[4], g_my_mac[5]);
    fflush(stdout);
    
    // Generate random DHCP transaction ID
    g_dhcp_xid = (UINT32)rand();
    printf("[MacOsTunInit] Generated DHCP XID: 0x%08x\n", g_dhcp_xid);
    fflush(stdout);
    
    // Create synchronization objects
    printf("[MacOsTunInit] Creating synchronization objects...\n");
    fflush(stdout);
    ctx->cancel = NewCancel();
    printf("[MacOsTunInit] Cancel created\n");
    fflush(stdout);
    ctx->recv_queue = NewQueue();
    printf("[MacOsTunInit] Queue created\n");
    fflush(stdout);
    ctx->queue_lock = NewLock();
    printf("[MacOsTunInit] Lock created\n");
    fflush(stdout);
    
    // Start background read thread
    printf("[MacOsTunInit] Starting background read thread...\n");
    fflush(stdout);
    ctx->read_thread = NewThread(MacOsTunReadThread, ctx);
    printf("[MacOsTunInit] NewThread returned, waiting for init...\n");
    fflush(stdout);
    WaitThreadInit(ctx->read_thread);
    printf("[MacOsTunInit] Thread initialized\n");
    fflush(stdout);
    
    // Store context in packet adapter
    s->PacketAdapter->Param = ctx;
    
    printf("[MacOsTunInit] === SUCCESS === TUN device: %s\n", ctx->device_name);
    fflush(stdout);
    return true;
}

// PA_GETCANCEL callback - Get cancellation object
CANCEL* MacOsTunGetCancel(SESSION *s) {
    MACOS_TUN_CONTEXT *ctx;
    CANCEL *c;
    
    if (s == NULL || s->PacketAdapter == NULL) {
        return NULL;
    }
    
    ctx = (MACOS_TUN_CONTEXT *)s->PacketAdapter->Param;
    if (ctx == NULL || ctx->cancel == NULL) {
        return NULL;
    }
    
    // Important: AddRef before returning because caller will ReleaseCancel
    c = ctx->cancel;
    AddRef(c->ref);
    
    return c;
}

// PA_GETNEXTPACKET callback - Get next packet from TUN device
UINT MacOsTunGetNextPacket(SESSION *s, void **data) {
    MACOS_TUN_CONTEXT *ctx;
    TUN_PACKET *pkt;
    UINT size = 0;
    
    if (s == NULL || s->PacketAdapter == NULL || data == NULL) {
        return 0;
    }
    
    ctx = (MACOS_TUN_CONTEXT *)s->PacketAdapter->Param;
    if (ctx == NULL) {
        return 0;
    }
    
    // Send DHCP DISCOVER if not yet requested
    if (g_dhcp_state == DHCP_STATE_INIT) {
        UINT dhcp_size;
        UCHAR *dhcp_pkt = BuildDhcpDiscover(g_my_mac, g_dhcp_xid, &dhcp_size);
        if (dhcp_size > 0 && dhcp_pkt != NULL) {
            printf("[MacOsTunGetNextPacket] Sending DHCP DISCOVER (xid=0x%08x, size=%u)\n", g_dhcp_xid, dhcp_size);
            printf("[MacOsTunGetNextPacket] First 100 bytes: ");
            for (UINT i = 0; i < (dhcp_size < 100 ? dhcp_size : 100); i++) {
                printf("%02x ", dhcp_pkt[i]);
            }
            printf("\n");
            // Allocate a copy for the session (static buffer will be reused)
            UCHAR *pkt_copy = Malloc(dhcp_size);
            memcpy(pkt_copy, dhcp_pkt, dhcp_size);
            *data = pkt_copy;
            g_dhcp_state = DHCP_STATE_DISCOVER_SENT;
            return dhcp_size;
        }
    }
    
    // Send DHCP REQUEST after receiving OFFER
    if (g_dhcp_state == DHCP_STATE_OFFER_RECEIVED) {
        UINT dhcp_size;
        UCHAR *dhcp_pkt = BuildDhcpRequest(g_my_mac, g_dhcp_xid, g_offered_ip, g_dhcp_server_ip, &dhcp_size);
        if (dhcp_size > 0 && dhcp_pkt != NULL) {
            printf("[MacOsTunGetNextPacket] ðŸ“¤ Sending DHCP REQUEST for IP (xid=0x%08x, size=%u)\n", g_dhcp_xid, dhcp_size);
            // Allocate a copy for the session
            UCHAR *pkt_copy = Malloc(dhcp_size);
            memcpy(pkt_copy, dhcp_pkt, dhcp_size);
            *data = pkt_copy;
            g_dhcp_state = DHCP_STATE_REQUEST_SENT;
            return dhcp_size;
        }
    }
    
    // Try to get packet from queue
    Lock(ctx->queue_lock);
    {
        pkt = (TUN_PACKET *)GetNext(ctx->recv_queue);
        if (pkt != NULL) {
            *data = pkt->data;
            size = pkt->size;
            Free(pkt); // Free wrapper, but data is returned to caller
        }
    }
    Unlock(ctx->queue_lock);
    
    return size;
}

// PA_PUTPACKET callback - Send packet to TUN device
bool MacOsTunPutPacket(SESSION *s, void *data, UINT size) {
    MACOS_TUN_CONTEXT *ctx;
    UCHAR buf[MAX_PACKET_SIZE];
    int n;
    
    if (s == NULL || s->PacketAdapter == NULL) {
        return false;
    }
    
    // Handle flush call (data=NULL, size=0) - just return success
    if (data == NULL || size == 0) {
        return true;
    }
    
    ctx = (MACOS_TUN_CONTEXT *)s->PacketAdapter->Param;
    if (ctx == NULL || ctx->tun_fd < 0) {
        return false;
    }
    
    // Debug: Log all incoming packets during DHCP
    if (g_dhcp_state != DHCP_STATE_CONFIGURED && size > 14) {
        USHORT ethertype = (((UCHAR*)data)[12] << 8) | ((UCHAR*)data)[13];
        printf("[MacOsTunPutPacket] Incoming packet: size=%u, ethertype=0x%04x, state=%d\n", size, ethertype, g_dhcp_state);
        
        if (ethertype == 0x0800) {
            // Check if it's UDP port 68 (DHCP client port)
            UCHAR *ip_hdr = (UCHAR*)data + 14;
            if (size >= 34 && ip_hdr[9] == 17) { // Protocol = UDP
                // CRITICAL FIX: Calculate IP header length from IHL field (lower 4 bits of first byte)
                UINT ip_hdr_len = (ip_hdr[0] & 0x0F) * 4;
                if (size >= 14 + ip_hdr_len + 8) { // Need room for UDP header
                    UCHAR *udp_hdr = ip_hdr + ip_hdr_len;
                    USHORT src_port = (udp_hdr[0] << 8) | udp_hdr[1];
                    USHORT dest_port = (udp_hdr[2] << 8) | udp_hdr[3];
                    printf("[MacOsTunPutPacket] ðŸ“© UDP packet: src_port=%u, dest_port=%u\n", src_port, dest_port);
                
                if (dest_port == 68 || src_port == 67) {
                    printf("[MacOsTunPutPacket] ï¿½ This is a DHCP packet! Parsing...\n");
                    // Dump first 100 bytes for debugging
                    printf("[MacOsTunPutPacket] First 100 bytes: ");
                    for (int i = 0; i < (size < 100 ? size : 100); i++) {
                        printf("%02x ", ((UCHAR*)data)[i]);
                    }
                    printf("\n");
                }
            }
        }
    }
    
    // Handle DHCP responses
    if (g_dhcp_state != DHCP_STATE_CONFIGURED && size > 14) {
        // Check for DHCP OFFER
        if (g_dhcp_state == DHCP_STATE_DISCOVER_SENT) {
            UINT32 ip, mask, gw, server;
            if (ParseDhcpOffer(data, size, g_dhcp_xid, &ip, &mask, &gw, &server)) {
                printf("[MacOsTunPutPacket] ðŸ“¨ DHCP OFFER received!\n");
                printf("  Offered IP: %u.%u.%u.%u\n", 
                       (ip >> 24) & 0xFF, (ip >> 16) & 0xFF, (ip >> 8) & 0xFF, ip & 0xFF);
                printf("  Netmask:    %u.%u.%u.%u\n",
                       (mask >> 24) & 0xFF, (mask >> 16) & 0xFF, (mask >> 8) & 0xFF, mask & 0xFF);
                printf("  Gateway:    %u.%u.%u.%u\n",
                       (gw >> 24) & 0xFF, (gw >> 16) & 0xFF, (gw >> 8) & 0xFF, gw & 0xFF);
                printf("  Server:     %u.%u.%u.%u\n",
                       (server >> 24) & 0xFF, (server >> 16) & 0xFF, (server >> 8) & 0xFF, server & 0xFF);
                
                g_offered_ip = ip;
                g_offered_mask = mask;
                g_offered_gw = gw;
                g_dhcp_server_ip = server;
                g_dhcp_state = DHCP_STATE_OFFER_RECEIVED;
                // Don't write DHCP packets to TUN
                return true;
            }
        }
        
        // Check for DHCP ACK
        if (g_dhcp_state == DHCP_STATE_REQUEST_SENT) {
            UINT32 ip, mask, gw;
            if (ParseDhcpAck(data, size, g_dhcp_xid, &ip, &mask, &gw)) {
                printf("[MacOsTunPutPacket] ðŸŽ‰ DHCP ACK received!\n");
                
                if (ConfigureTunInterface(ctx->device_name, ip, mask, gw)) {
                    g_dhcp_state = DHCP_STATE_CONFIGURED;
                }
                // Don't write DHCP packets to TUN
                return true;
            }
        }
    }
    
    if (size > TUN_MTU) {
        printf("[MacOsTunPutPacket] Packet too large: %u bytes\n", size);
        return false;
    }
    
    UCHAR *pkt = (UCHAR *)data;
    UCHAR *ip_packet = pkt;
    UINT ip_size = size;
    UINT32 proto;
    
    // Check if this is an Ethernet frame (Layer 2) that needs stripping
    // Ethernet frame: [6 bytes dest MAC][6 bytes src MAC][2 bytes EtherType][payload]
    if (size >= 14) {
        USHORT ethertype = (pkt[12] << 8) | pkt[13];
        
        if (ethertype == 0x0800) {
            // IPv4 in Ethernet frame - strip the 14-byte Ethernet header
            ip_packet = pkt + 14;
            ip_size = size - 14;
            proto = htonl(AF_INET);
        } else if (ethertype == 0x86DD) {
            // IPv6 in Ethernet frame - strip the 14-byte Ethernet header
            ip_packet = pkt + 14;
            ip_size = size - 14;
            proto = htonl(AF_INET6);
        } else if ((pkt[0] & 0xF0) == 0x40) {
            // Raw IPv4 packet (no Ethernet header)
            proto = htonl(AF_INET);
        } else if ((pkt[0] & 0xF0) == 0x60) {
            // Raw IPv6 packet (no Ethernet header)
            proto = htonl(AF_INET6);
        } else {
            // Unknown protocol - skip it
            printf("[MacOsTunPutPacket] Skipping unknown EtherType 0x%04x\n", ethertype);
            return true;
        }
    } else if (size > 0 && (pkt[0] & 0xF0) == 0x40) {
        // Raw IPv4 packet
        proto = htonl(AF_INET);
    } else if (size > 0 && (pkt[0] & 0xF0) == 0x60) {
        // Raw IPv6 packet
        proto = htonl(AF_INET6);
    } else {
        // Too small or unknown - skip it
        return true;
    }
    
    // Write protocol header + packet
    Copy(buf, &proto, 4);
    Copy(buf + 4, ip_packet, ip_size);
    
    n = write(ctx->tun_fd, buf, ip_size + 4);
    if (n < 0) {
        if (errno != EINTR && errno != EAGAIN) {
            printf("[MacOsTunPutPacket] Write error: %s\n", strerror(errno));
            return false;
        }
        return true; // Temporary error, consider success
    }
    
    ctx->bytes_sent += ip_size;
    ctx->packets_sent++;
    
    return true;
}

// PA_FREE callback - Cleanup TUN device
void MacOsTunFree(SESSION *s) {
    MACOS_TUN_CONTEXT *ctx;
    TUN_PACKET *pkt;
    
    printf("[MacOsTunFree] Cleaning up macOS TUN adapter\n");
    
    if (s == NULL || s->PacketAdapter == NULL) {
        return;
    }
    
    ctx = (MACOS_TUN_CONTEXT *)s->PacketAdapter->Param;
    if (ctx == NULL) {
        return;
    }
    
    // Stop read thread
    ctx->halt = true;
    if (ctx->cancel) {
        Cancel(ctx->cancel);
    }
    
    if (ctx->read_thread) {
        WaitThread(ctx->read_thread, 5000);
        ReleaseThread(ctx->read_thread);
    }
    
    // Close TUN device
    CloseMacOsTunDevice(ctx->tun_fd);
    
    // Free queued packets
    if (ctx->recv_queue) {
        Lock(ctx->queue_lock);
        {
            while ((pkt = (TUN_PACKET *)GetNext(ctx->recv_queue)) != NULL) {
                Free(pkt->data);
                Free(pkt);
            }
        }
        Unlock(ctx->queue_lock);
        ReleaseQueue(ctx->recv_queue);
    }
    
    // Free synchronization objects
    if (ctx->queue_lock) {
        DeleteLock(ctx->queue_lock);
    }
    if (ctx->cancel) {
        ReleaseCancel(ctx->cancel);
    }
    
    printf("[MacOsTunFree] Statistics - Sent: %llu packets (%llu bytes), Received: %llu packets (%llu bytes)\n",
           ctx->packets_sent, ctx->bytes_sent, ctx->packets_received, ctx->bytes_received);
    
    Free(ctx);
    s->PacketAdapter->Param = NULL;
    
    printf("[MacOsTunFree] Cleanup complete\n");
}

// Create a new macOS TUN packet adapter
PACKET_ADAPTER* NewMacOsTunAdapter() {
    PACKET_ADAPTER *pa;
    
    printf("[NewMacOsTunAdapter] Creating macOS TUN packet adapter\n");
    fflush(stdout);
    
    printf("[NewMacOsTunAdapter] Calling NewPacketAdapter with callbacks:\n");
    printf("  Init=%p, GetCancel=%p, GetNext=%p, Put=%p, Free=%p\n",
           MacOsTunInit, MacOsTunGetCancel, MacOsTunGetNextPacket,
           MacOsTunPutPacket, MacOsTunFree);
    fflush(stdout);
    
    pa = NewPacketAdapter(
        MacOsTunInit,
        MacOsTunGetCancel,
        MacOsTunGetNextPacket,
        MacOsTunPutPacket,
        MacOsTunFree
    );
    
    printf("[NewMacOsTunAdapter] NewPacketAdapter returned: %p\n", pa);
    fflush(stdout);
    
    if (pa) {
        pa->Id = PACKET_ADAPTER_ID_VLAN_WIN32; // Reuse ID since it's just for tracking
        pa->Param = NULL; // Will be set in Init callback
        printf("[NewMacOsTunAdapter] Set pa->Id=%u, pa->Param=%p\n", pa->Id, pa->Param);
        printf("[NewMacOsTunAdapter] Packet adapter created successfully\n");
        fflush(stdout);
    } else {
        printf("[NewMacOsTunAdapter] Failed to create packet adapter\n");
        fflush(stdout);
    }
    
    return pa;
}
